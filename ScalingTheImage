#include <iostream>
#include <boost/graph/graph_traits.hpp>
#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/adjacency_iterator.hpp>
#include <vector>
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <math.h>

using namespace std;
using namespace cv;

struct VertexProperty {
  char name;
  Point2d pt;
};


typedef boost::property<boost::edge_weight_t, double> EdgeProperty;
typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS, VertexProperty, EdgeProperty> Graph;
typedef boost::graph_traits<Graph>::vertex_iterator VItr;
typedef boost::graph_traits<Graph>::edge_iterator EItr;
typedef boost::graph_traits<Graph>::adjacency_iterator adjacency_iterator;
typedef boost::property_map<Graph, boost::vertex_index_t>::type IndexMap;
typedef boost::graph_traits<Graph>::edge_iterator EdgeIterator;
typedef std::pair<EdgeIterator, EdgeIterator> EdgePair;
typedef boost::graph_traits<Graph>::vertex_descriptor VertexDescriptor;
typedef vector<pair< pair< Point2d, Point2d>, double> > EdgeLinear;

		const double big_constant = 1e+64;
	const Scalar white = CV_RGB (255, 255, 255);
	const Scalar black = CV_RGB (0, 0, 0);

class Data

{

public:

    Point2d point;

    Data (Point2d p) { point = p; }

};


void Bounding_Box (std::vector<Data>const& cloud, std::pair<Point2d,
Point2d>& cloud_box ) {

    cloud_box.first = Point2d( big_constant, big_constant );

    cloud_box.second = Point2d( -big_constant, -big_constant );

    for ( auto p : cloud )   {

        if ( cloud_box.first.x > p.point.x ) cloud_box.first.x = p.point.x;

        if ( cloud_box.first.y > p.point.y ) cloud_box.first.y = p.point.y;

        if ( cloud_box.second.x < p.point.x ) cloud_box.second.x = p.point.x;

        if ( cloud_box.second.y < p.point.y ) cloud_box.second.y = p.point.y;

    }

}

void Scaling_Parameters (std::vector<Data>const& cloud, Point
image_sizes, double& scale, Point2d& shift) {

    std::pair<Point2d, Point2d> box;

    Bounding_Box( cloud, box );

    Point2d cloud_sizes( box.second.x - box.first.x, box.second.y -
box.first.y );

    Point2d cloud_center( box.second.x + box.first.x, box.second.y +
box.first.y );

    cloud_center.x /= 2;
	cloud_center.y /= 2;

    Point2d image_center( image_sizes.x / 2, image_sizes.y / 2 );

    scale = std::min( image_sizes.x / cloud_sizes.x, image_sizes.y /
cloud_sizes.y );

shift = image_center - scale * cloud_center;

}

void Draw_Cloud (std::vector<Data>const& cloud, int radius, Scalar
color, Mat& image) {

    double scale;

    Point2d shift;

    Scaling_Parameters( cloud, image.size(), scale, shift );

    for ( auto p : cloud )

        cv::circle( image, Point( scale * p.point.x + shift.x, scale * p.point.y + shift.y ), radius,color, -1 );
}

int main(){

	std::vector<Data> cloud{ Data( Point2d(0,0) ), Data( Point2d(1,1) ) };

	Point image_sizes( 200, 100 );

	Mat image( image_sizes, CV_8UC3, white );

	Draw_Cloud( cloud, 2, black, image );

	imwrite("cloud.png", image );	
}
